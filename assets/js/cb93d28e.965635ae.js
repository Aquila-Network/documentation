"use strict";(self.webpackChunkaquila=self.webpackChunkaquila||[]).push([[442],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=i.createContext({}),l=function(e){var t=i.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=l(e.components);return i.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=l(n),m=r,h=d["".concat(c,".").concat(m)]||d[m]||p[m]||a;return n?i.createElement(h,o(o({ref:t},u),{},{components:n})):i.createElement(h,o({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var l=2;l<a;l++)o[l]=n[l];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9944:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return u},default:function(){return d}});var i=n(7462),r=n(3366),a=(n(7294),n(3905)),o=["components"],s={sidebar_position:2},c="Asymmetric key signing",l={unversionedId:"db/concepts/authentication/Asymmetric key signing",id:"db/concepts/authentication/Asymmetric key signing",isDocsHomePage:!1,title:"Asymmetric key signing",description:"Aquila DB currently supports wallets that use private-public key pairs to sign messages. The wallets that support public key cryptography optionally, DIDs thus becomes compatible by default. An asymmetric key pair enables independent signing of messages (to claim ownership) with a private key at the client (user) side and validation of the claim at the server (Aquila DB and others) side. The biggest advantages this independency can offer are the following:",source:"@site/docs/db/concepts/authentication/Asymmetric key signing.md",sourceDirName:"db/concepts/authentication",slug:"/db/concepts/authentication/Asymmetric key signing",permalink:"/docs/db/concepts/authentication/Asymmetric key signing",editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/db/concepts/authentication/Asymmetric key signing.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Authentication & Ownership",permalink:"/docs/db/concepts/authentication/Authentication & Ownership"},next:{title:"Notion of a wallet",permalink:"/docs/db/concepts/authentication/Notion of a wallet"}},u=[{value:"Pseudo-code for generating signature of a JSON request",id:"pseudo-code-for-generating-signature-of-a-json-request",children:[],level:4},{value:"RSA",id:"rsa",children:[{value:"RSASSA-PKCS1-v1_5 (PKCS#1)",id:"rsassa-pkcs1-v1_5-pkcs1",children:[],level:5},{value:"RSASSA-PSS",id:"rsassa-pss",children:[],level:5}],level:3},{value:"ECDSA",id:"ecdsa",children:[],level:3}],p={toc:u};function d(e){var t=e.components,n=(0,r.Z)(e,o);return(0,a.kt)("wrapper",(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"asymmetric-key-signing"},"Asymmetric key signing"),(0,a.kt)("p",null,"Aquila DB currently supports wallets that use private-public key pairs to sign messages. The wallets that support public key cryptography optionally, DIDs thus becomes compatible by default. An asymmetric key pair enables independent signing of messages (to claim ownership) with a private key at the client (user) side and validation of the claim at the server (Aquila DB and others) side. The biggest advantages this independency can offer are the following:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Aquila Network APIs can be configured to Authenticate and Authorize requests based on their DID signatures."),(0,a.kt)("li",{parentName:"ul"},"Aquila DB is an eventually consistent database. This means the document operations can wait and be validated at any point of time without maintaining a session with the client."),(0,a.kt)("li",{parentName:"ul"},"Eventual consistency is applicable to replication of documents through the network. Any node in the Aquila Network could validate the replicated document of its ownership."),(0,a.kt)("li",{parentName:"ul"},"A node in the Aquila Network can be configured to accept / reject certain documents based on their signatures or owners. "),(0,a.kt)("li",{parentName:"ul"},"Any document in the Aquila Network is by default associated with a DID, which brings in trust from the real / virtual world over time."),(0,a.kt)("li",{parentName:"ul"},"In later times, DIDs can be rewarded for their value addition as data / information to the network or as a node executor.")),(0,a.kt)("h4",{id:"pseudo-code-for-generating-signature-of-a-json-request"},"Pseudo-code for generating signature of a JSON request"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'def sign_message (JSON_request)\n    bson_request = bson(JSON_request)\n    hash = SHA384(bson_request)\n    \n    # Sign with pvt key\n    signature = pkcs1_15(hash, priv_key)\n    signature = base58(signature).decode("utf-8")\n')),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"JSON_request formats depends upon the type of operation. Please refer API specifications for each module for more information")),(0,a.kt)("h3",{id:"rsa"},"RSA"),(0,a.kt)("h5",{id:"rsassa-pkcs1-v1_5-pkcs1"},"RSASSA-PKCS1-v1_5 (PKCS#1)"),(0,a.kt)("p",null,"Currently Aquila DB supports the following PKCS#1 configuration to validate signatures:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"RSA Private-Key: (2048 bit, 2 primes)\n\nHashing algorithm: RSA-SHA384\n")),(0,a.kt)("h5",{id:"rsassa-pss"},"RSASSA-PSS"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"coming soon")),(0,a.kt)("h3",{id:"ecdsa"},"ECDSA"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"coming soon")))}d.isMDXComponent=!0}}]);